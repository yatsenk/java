package JavaАlg1Lesson5;

import java.util.Random;

/**
 * Самый важный итог урока 5: чем лучше ты спроектируешь код до начала работы над ним,
 * и чем точнее поставишь граничные условия - тем меньше тебе писать и переписывать,
 * тем меньше ты индус.
 * Для этого, конечно, надо сначала понимать проектируемый предмет.
 */

public class Main {

    /**
     * Сравниваем алгоритмы жадного выбора и полного перебора на размере 6,
     * иначе у меня падает стек в связи с максимально занудным и рекурсивным описанием перебора.
     * Строка 69 - оптимизированная версия, которая не падает.
     *
     * Мораль рекурсии:
     * - меньше кода рекурсии - лучше стеку
     * - больше нерекурсивных процедур, вызываемых рекурсией
     */
    public static void main(String[] args) {
        testExp(); // про эту часть домашки я как-то забыл, но после второй части писать ее минут пять.
        testBackpack(); // много разного экспериментального кода
    }

    public static void testExp(){
        int num,exp;
        num = 5;
        exp = 10;

        Exponent e = new Exponent();
        System.out.println(num + " в степени " + exp + " равно: " + e.calc(num,exp));
        System.out.println();
    }

    public static void testBackpack(){
        final int ITEMS_QUANTITY = 13; // 15 предметов будет считать 25-30 часов

        final int MAX_WEIGHT = 20; // коэффициенты подобраны экспериментально, чтобы наглядно видеть отличия между алгоритмами
        final int BOUND_WEIGHT = 10;
        final int BOUND_COST = 10;

        Random rnd = new Random();
        Item [] array = new Item[ITEMS_QUANTITY];

        for (int i = 0; i < ITEMS_QUANTITY; i++) {
            array[i] = new Item(rnd.nextInt(BOUND_WEIGHT)+1,rnd.nextInt(BOUND_COST)+1);
        }

        Greedy g = new Greedy(array,MAX_WEIGHT);
        NP np = new NP (array,MAX_WEIGHT);

        g.display();
        System.out.println();
        System.out.print("1. Жадный алгоритм.");
        g.calc();
        g.display();

        long start = System.currentTimeMillis();
        System.out.println();
        System.out.println("2. Полный перебор.");
        //np.calcLotsOfMemoryAndRake(); // падает на 6 предметах
        np.startQuickNP(); // не падает на 15 предметах
        np.display();
        long finish = System.currentTimeMillis();
        System.out.println();
        System.out.println(finish - start + " ms полного перебора");
    }

    /**
     * До последней оптимизации, но с потоковым копированием List ==> Array
     * 13 предметов, 400 секунд вычислений
     *
     * 1. Жадный алгоритм.
     * Выбранные предметы:
     * Вес предмета: 1, стоимость предмета: 6.
     * Вес предмета: 2, стоимость предмета: 10.
     * Вес предмета: 4, стоимость предмета: 8.
     * Вес предмета: 7, стоимость предмета: 10.
     * Вес предмета: 6, стоимость предмета: 6.
     * Общий вес: 20 общая стоимость: 40
     *
     * 2. Полный перебор.
     * Выбранные предметы:
     * Вес предмета: 2, стоимость предмета: 10.
     * Вес предмета: 7, стоимость предмета: 10.
     * Вес предмета: 4, стоимость предмета: 3.
     * Вес предмета: 2, стоимость предмета: 10.
     * Вес предмета: 4, стоимость предмета: 8.
     * Общий вес: 19 общая стоимость: 41
     *
     * 399073 ms полного перебора
     */

    /**
     * Время выполнения увеличилось из-за исправленного метода quickNPRotate,
     * так что производительность оптимизаций мы напрямую не сравним (+более 20%)
     *
     * 1. Жадный алгоритм.
     * Выбранные предметы:
     * Вес предмета: 1, стоимость предмета: 10.
     * Вес предмета: 1, стоимость предмета: 7.
     * Вес предмета: 1, стоимость предмета: 3.
     * Вес предмета: 2, стоимость предмета: 6.
     * Вес предмета: 4, стоимость предмета: 9.
     * Вес предмета: 6, стоимость предмета: 8.
     * Вес предмета: 4, стоимость предмета: 2.
     * Общий вес: 19 общая стоимость: 45
     *
     * 2. Полный перебор.
     * Выбранные предметы:
     * Вес предмета: 4, стоимость предмета: 2.
     * Вес предмета: 1, стоимость предмета: 10.
     * Вес предмета: 1, стоимость предмета: 7.
     * Вес предмета: 1, стоимость предмета: 3.
     * Вес предмета: 2, стоимость предмета: 6.
     * Вес предмета: 4, стоимость предмета: 9.
     * Вес предмета: 6, стоимость предмета: 8.
     * Общий вес: 19 общая стоимость: 45
     *
     * 316416 ms полного перебора
     */
}
